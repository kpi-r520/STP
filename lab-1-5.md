# Современные технологии программирования - 2
## Лабораторная работа №5. ШАБЛОНЫ «АБСТРАКТНАЯ ФАБРИКА», «ФАБРИЧНЫЙ МЕТОД», «МЕМЕНТО», «ОБОЗРЕВАТЕЛЬ», «ДЕКОРАТОР»

### Задание

1. Ознакомиться с краткими теоретическими сведениями.
2. Реализовать часть функционала рабочей программы в виде классов и их взаимодействий для достижения конкретных функциональных возможностей.
3. Применение одного из рассматриваемых шаблонов при реализации программы.


### Теоретическая часть

CLR, JIT. Extension methods, indexers, generics. Ковариантность и контрвариантность. Исключительные ситуации и их обработка. Необрабатываемые исключительные ситуации. SOLID.

### Краткие теоретические сведения

**Принципы проектирования SOLID**

Принципы проектирования SOLID были введены Робертом Мартином в его статье «Объектно-ориентированное проектирование» и относятся к разработке классов систем. Вот они:

*S SRP Принцип единственной обязанности*

На каждый объект должна быть возложена одна единственная обязанность.

*O OCP Принцип открытости/закрытости*

Программные сущности … должны быть открыты для расширения, но закрыты для изменения.

*L LSP Принцип подстановки Барбары Лисков*

Объекты в программе могут быть заменены их наследниками без изменения свойств программы. См. также контрактное программирование. 

*I ISP Принцип разделения интерфейса*

Много специализированных интерфейсов лучше, чем один универсальный.

*D DIP Принцип инверсии зависимостей*

Зависимости внутри системы строятся на основе абстракций. Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Принцип единственной ответственности (single responsibility principle) гласит о необходимости создания классов, отвечающих не более чем за одну вещь. Проблема, которая возникает когда один класс содержит множество обязанностей – прежде всего, плохая читаемость кода (как правило, такие классы разрастаются до невероятных размеров и становится практически невозможной их дальнейшяя поддержка), и сложность изменения. Например, если служба отчетов тесно интегрирована со службой печати (в одном классе), то изменения в одной из служб наверняка приведут к поломке другой. Этот принцип также ведет к уменьшению связанности компонент (low coupling) и повышению целостности элементов системы (high cohesion).

Принцип открытости/закрытости провозглашает необходимость добавления возможности расширения без изменения исходных кодов самого компонента. Таким образом существует возможность изменения поведения компонента без затрагивания исходных кодов, что может понадобиться в случае тестирования (замена отдельных компонент заглушками) или добавления функциональности. Одной из реализаций принципов открытости/закрытости является реализация интерфейсов или абстрактных классов для спецификации семантики необходимых действий (контракт предоставляемых услуг), и предоставление возможностей к собственной реализации этих интерфейсов(конкретная реализация).

Принцип подстановки Барбары Лисков утверждает, что подклассы в иерархии классов должны сохранять функциональность, аналогичную родительским классам. Т.е. подстановка подклассов должна оставить программу функционировать тем же образом (корректно). Проблема происходит из следующих соображений: допустим, реализовывается класс калькулятор; создается дочерний класс «цифровой калькулятор», но в перегрузке метода «сумма» используется умножение. Синтаксически, такое использование дочерних классов не несет ошибок (компилируется и запускается). Семантически, результат работы программы абсолютно поменяется при замене родительского класса подклассом (каждый раз при суммировании мы будем на самом деле умножать). Принцип гласит о необходимости сохранять семантику базового класса во избежание нелепых поломок в программном обеспечении.

Основной идеей принципа разделения интерфейсов является разбиение общего «контракта» (или набора предоставляемых услуг) программы на множество мелких интерфейсных модулей, которые отвечают за одну конкретную работу. Такой подход напоминает принцип одной обязанности, но относится ко всей системе в целом, и упрощает чтение, понимание и модификацию системы, поскольку пользователи интерфейса видят лишь тот «разрез» системы, который им в данный момент нужен.

Принцип инверсии зависимостей утверждает о необходимости устранения зависимостей модулей верхнего уровня (более объемлющих и глобальных) от модулей нижнего уровня, поскольку и те и другие должны ссылаться на абстракции (интерфейсы). Абстракции, в свою очередь, не должны зависеть от деталей, а наоборот. Проще всего понять этот принцип на конкретном примере: пускай существует некоторая служба, производящая конкретные расчеты (назовем ее Служба1); существует служба, которая имеет ссылку на нее, и использует для реализации собственной внутренней механики (назовем ее служба2). Реализация этого принципа будет выглядеть следующим образом: у службы1 будет вынесен общий интерфейс, и этот интерфейс будет использоваться в службе2 (подставляться в конструктор, например). Таким образом, служба1 зависит от абстракции (общий интерфейс), и не влияет на работу службы2(модули верхнего уровня не зависят от модулей нижнего уровня). Абстракция в свою очередь не зависит от деталей, поскольку является простой спецификацией возможных действий. Следует отметить, что данный принцип хорошо сочетается с предыдущими, и позволяет составлять более робастные и чистые приложения. Существует множество реализаций этого принципа – внедрение зависимостей, система расширений, локатор служб.

**Шаблон «Абстрактная фабрика»**

![Абстрактная фабрика](https://github.com/kpi-r520/STP/blob/master/images/abstract_factory_diagram.png)

Шаблон «абстрактная фабрика» используется для создания семейств объектов без указания их конкретных классов. Для этого выносится общий интерфейс фабрики (AbstractFactory) и создаются его реализации для различных семейств продуктов. Хорошим примером использования абстрактной фабрики является ADO.NET: существует общий класс DbProviderFactory, способный создавать объекты типов DbConnection, DbDataReader, DbAdapter и др.; существуют реализации этих фабрик и объектов - SqlProviderFactory, SqlConnection, SqlDataReader, SqlAdapter и т.д. Соответственно, если приложению необходимо работать с различными базами данных (или необходима такая возможность), то достаточно использовать базовые реализации (Db..) и подставить соответствующую фабрику в момент инициализации фабрики (Factory = new SqlProviderFactory()).

Данный шаблон прежде всего структурирует знания о похожих объектах (называемых семействами, как классы для доступа к БД) и создает возможность взаимозамены различных семейств (работа с Oracle ведется также, как и работа с SQL Server). Однако, при использовании такой схемы крайне неудобно расширять фабрику – для добавления нового метода в фабрику необходимо добавить его во всех фабриках и создать соответствующие классы, создаваемые этим методом.

**Шаблон «Фабричный метод»**

![Фабричный метод](https://github.com/kpi-r520/STP/blob/master/images/factory_method_diagram.png)

Шаблон «фабричный метод» определяет интерфейс для создания объектов определенного базового типа. Это удобно, когда хочется добавить возможность создания объектов не базового типа, а некоторого дочернего. Фабричный метод в таком случае представляет собой зацепку для внедрения собственного конструктора объектов. Основная идея заключается именно в замене объектов их подтипами, при этом сохраняющим ту же функциональность; остальная часть поведения объектов не является интерфейсной (AnOperation) и позволяет взаимодействовать с созданными объектами как с объектами базового типа. Поэтому шаблон «фабричный метод» носит еще название «виртуальный конструктор».

Рассмотрим простой пример. Пускай наше приложение работает с сетевыми драйверами и использует класс Packet для хранения данных, передаваемых в сеть. В зависимости от используемого протокола, существует две перегрузки – TcpPacket, UdpPacket. И соответственно два создающих объекта (TcpCreator, UdpCreator) с фабричным методом (который создает соответствующие реализации). Однако базовая функциональность (передача пакета, прием пакета, заполнение пакета данными) ничем не отличается друг от друга, соответственно помещается в базовый класс PacketCreator. Таким образом поведение системы остается тем же, однако появляется возможность подстановки собственных объектов в процесс создания и работы с пакетами.

**Шаблон «Мементо»**

![«Мементо»](https://github.com/kpi-r520/STP/blob/master/images/memento_diagram.png)

Шаблон используется для сохранения и восстановления состояния объектов без нарушения инкапсуляции. Объект «мементо» служит исключительно для сохранения изменений над исходным объектом (Originator). Лишь исходный объект имеет возможность сохранять и получать состояние объекта «мементо» для собственных целей, данный объект является «пустым» для кого-либо еще. Объект Caretaker используется для передачи и хранения мементо-объектов в системе. Таким образом удается достичь следующих целей:

* Хранение состояния полностью отделяется от исходных объектов, что облегчает их реализацию;
* Передача объектов мементо ложится на плечи Caretaker объектов, что позволяет более гибко управлять состояниями объектов и упростить дизайн классов исходных объектов;
* Сохранение и восстановление состояния реализованы в виде двух простых методов и являются закрытыми для кого-либо еще кроме исходных объектов, таким образом не нарушая инкапсуляцию.

Шаблон «мементо» очень удобно использовать вместе с шаблоном «команда» для реализации «отменяемых» действий – данные о действии сохраняются в мементо, а команда имеет возможность считать и восстановить исходное положение соответствующих объектов.

Шаблон «Обозреватель»

![«Обозреватель»](https://github.com/kpi-r520/STP/blob/master/images/observer_diagram.png)

Шаблон определяет зависимость «один-ко-многим» таким образом, что когда один объект изменяет собственное состояние, все остальные объекты получают об этом извещение и имеют возможность изменить собственое состояние также.

Рассмотрим этот шаблон на примере. Допустим, есть некоторая банковская система, и несколько пользователей просматривают баланс на счету господина И. В этот момент господин И. ложит на свой счет некоторую сумму, которая меняет общий баланс. Каждый из пользователей, просматривавших баланс, получает об этом известие (для пользователей это известие может быть прозрачным – просто изменение цифр, или предупреждение о том, что баланс изменился). Ранее невозможные действия для пользователей (перевод в другую категорию клиентов и т.п.) становятся доступными.

Данный шаблон очень широко распространен в шаблоне MVVM и механизме «привязок»(bindings) в WPF и частично в WinForms. Другое название шаблона – подписка/рассылка. Каждый из обозревателей собственноручно подписывается на изменения конкретного объекта, а объекты обязаны извещать своих подписчиков о всех своих изменениях (на данный момент конкретных механизмов автоматического извещения о смене состояния в .NET языках не существует).

**Шаблон «Декоратор»**

![«Декоратор»](https://github.com/kpi-r520/STP/blob/master/images/decorator_diagram.png)

Шаблон предназначен для динамического добавления функциональных возможностей объекту во время работы программы. Декоратор некоторым образом «оборачивает» (аггрегация) исходный объект с сохранением его функций, однако позволяет добавить дополнительные действия. Такой шаблон предоставляет более гибкий способ изменения поведения объекта чем простое наследование, поскольку исходная функциональность сохраняется в полном объеме. Более того, такое поведение можно применять к отдельным объектам, а не ко всей системе в целом.

Простым примером является наложение полосы прокрутки ко всем визуальным элементам. Каждый объект, который может прокручиваться, оборачивается в «прокручиваемый» элемент, и при необходимости появляется полоса прокрутки. Исходные функции элемента (например, строки статуса) остаются неизменными.

Пример реализации такого шаблона:

```
/// <summary>
/// The ‘ConcreteDecorator’ class
/// </summary>
class Borrowable : Decorator
{
	protected List<string> borrowers = new List<string>();
	
	public Borrowable(LibraryItem libraryItem): base(libraryItem)
	{
	}
	
	public void BorrowItem(string name)
	{
		borrowers.Add(name);
		libraryItem.NumCopies--;
	}
	
	public void ReturnItem(string name)
	{
		borrowers.Remove(name);
		libraryItem.NumCopies++;
	}
	
	public override void Display()
	{
		base.Display();
		foreach (string borrower in borrowers)
		{
			Console.WriteLine(« borrower: « + borrower);
		}
	}
}
```

В данном случае к библиотечным элементам добавляется возможность аренды (книги и видео можно брать в аренду), при этом базовая функциональности (отображение данных) остается.

**Контрольные вопросы**

1. Расскажите про SOLID принципы проектирования.
2. Зачем используется шаблон «фабрика» ?
3. Чем отличается шаблон «фабрика» от «фабричного метода» ?
4. Какую функциональность добавляет шаблон «обозреватель»?
5. Какие ограничения использования шаблона «декоратор» ?