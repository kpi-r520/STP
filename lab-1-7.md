# Современные технологии программирования - 2
## Лабораторная работа №7. ШАБЛОНЫ «КОМПОЗИТНЫЙ ОБЪЕКТ», «FLYWEIGHT», «ИНТЕРПРЕТАТОР», «ПОСЕТИТЕЛЬ».

### Задание

1. Ознакомиться с краткими теоретическими сведениями.
2. Реализовать часть функционала рабочей программы в виде классов и их взаимодействий для достижения конкретных функциональных возможностей.
3. Применение одного из рассматриваемых шаблонов при реализации программы.

### Теоретическая часть

Способы синхронизации потоков. Шаблоны для работы с БД. ADO.NET, EF. DI, IoC. DLR.

### Краткие теоретические сведения

**Шаблоны работы с БД при разработке корпоративных приложений**

Существует набор современных шаблонов, используемых для разработчики широкомасштабных корпоративных приложений - с количеством пользователей более 100 и большим количеством взаимосвязанных приложений. Такие приложения требуют отдельных подходов к организации доступа к данным, поскольку количество хранимых данных, классов и обращающихся клиентов растет.

*Шаблон Активная запись (Active record)*

![Active Record](https://github.com/kpi-r520/STP/blob/master/images/active_record.png)

Один объект управляет и данными, и поведением. Большинство этих данных постоянны и их надо хранить в БД. Этот паттерн использует наиболее очевидный подход - хранение логики доступа к данным в объекте сущности.

Объект является «обёрткой» одной строки из БД или представления, включает в себя доступ к БД и логику обращения с данными.

Шаблон используется в частности в Ruby On Rails приложениях, ввиду его простоты. Однако с увеличением количества разнообразных запросов растет сложность класса данных и как правило логика запросов выносится в отдельный объект.

*Шаблон Шлюз к данным (Table Data Gateway)*

![Table Gateway](https://github.com/kpi-r520/STP/blob/master/images/table_gateway.png)

В данном случае отдельный класс для каждого класса данных занимается взаимодействием с базой данных. Он хранит в себе логику всех запросов (включая на сохранение и удаление записей). Такой подход более гибкий и тестируемый, и позволяет содержать отдельно данные и отдельно взаимодействие с базой данных. Однако для каждого шлюза к данным код взаимодействия как правило повторяется (соединение с базой, формирование команды источнику данных и т.п.), потому их часто абстрагируют в отдельный базовый класс для шлюзов. Еще такой шаблон часто называют репозиторий.

*Шаблон «отображение данных» (Data mapping)*

![Data Mapping](https://github.com/kpi-r520/STP/blob/master/images/data_mapping.png)

Крайне часто возникают проблема преобразования объекта данных в строку реляционного источника. Такая же проблема может возникать при необходимости передачи объекта по сети. Для ее решения принято создавать отдельные объекты (или методы внутри класса данных) для преобразования объектов данных в данные принимаемого источником вида. Эта процедура носит название отображения (mapping). Во время отображения исправляются все несоответствия типов данных между объектом данных и источником данных.

Типичный маппер – с объекта данных в таблицу реляционного источника данных. Он несет знание о названиях колонок в таблице и соответствующих свойствах объекта данных, которые соответствуют этим колонкам.

**Шаблон «Композитный объект»**

![Composite](https://github.com/kpi-r520/STP/blob/master/images/composite_diagram.png)

Шаблон используется для составления объектов в древовидную структуру для представления иерархий типа «часть целого». Данный шаблон позволяет унифицированно обрабатывать как единичные объекты, так и объекты с вложенностью.

Простым примером может служить составление компонентов внутри обыкновенной формы. Форма может содержать дочерние элементы (поля для ввода текста, цифр, надписи, рисунки и т.п.); дочерние элементы могут в свою очередь содержать другие элементы. Например, при выполнении операции растягивания формы необходимо, чтобы вся иерархия растянулась соответствующим образом. В таком случае форма рассматривается как композитный объект и операция растягивания применяется ко всем дочерним элементам рекурсивно.

Данный шаблон удобно использовать при необходимости представления и обработки иерархий объектов.

**Шаблон «Flyweight»**

![Flyweight](https://github.com/kpi-r520/STP/blob/master/images/flyweight_diagram.png)

Шаблон используется для уменьшения количества объектов в приложении путем разделения этих объектов между участками приложения. Flyweight представляет собой разделяемый объект. Хорошим примером является следующее изображение:

![Flyweight](https://github.com/kpi-r520/STP/blob/master/images/flyweight_diagram_2.png)

Кажется, будто для каждой буквы существует отдельный объект. На самом деле физически объект всего один, существует лишь множество ссылок на него.

Очень важной является концепция «внутреннего» и «внешнего» состояний. Внутреннее состояние отображает данные, характерные конкретно разделяемому объекту (например, код буквы); внешнее состояние несет информацию о его применении в приложении (например, строка и колонка). Внутреннее состояние сохраняется в самом разделяемом объекте, внешнее – в объектах приложения (контекста использования разделяемого объекта).

![Flyweight](https://github.com/kpi-r520/STP/blob/master/images/flyweight_diagram_3.png)

Данный шаблон очень хорошо применять в случаях, когда используется множество одинаковых объектов (например, графических примитивов).

**Шаблон интерпретатор**

![интерпретатор](https://github.com/kpi-r520/STP/blob/master/images/interpreter_diagram.png)

Данный шаблон используется для предоставления грамматики и интерпретатора для выбранного языка (например, скриптового). Грамматика языка представлена терминальными и нетерминальными символами, каждый из которых интерпретируется в контексте использования. Клиент передает контекст и сформированное предложение в используемом языке в терминах абстрактного синтаксического дерева (древовидная структура, однозначно определяющая иерархию вызова под-выражений), каждое выражение интерпретируется отдельно с использованием контекста. В случае наличия дочерних выражений, родительское выражение интерпретирует сначала дочерние (рекурсивно), а потом вычисляет результат собственной операции.

Шаблон удобно использовать в случае небольшой грамматики (иначе разрастется количество используемых классов) и относительно простого контекста (без взаимозависимостей и т.п.). Данный шаблон определяет базовый каркас интерпретатора, который с помощью рекурсии возвращает результат вычисления предложения на основе результатов отдельных элементов.

При использовании данного шаблона очень легко реализовывается и расширяется грамматика, а также добавляются новые способы интерпретации выражений.

**Шаблон «посетитель»**

![посетитель](https://github.com/kpi-r520/STP/blob/master/images/visitor_diagram.png)

Шаблон посетитель позволяет указывать операции над элементами без изменения структуры конкретных элементов. Таким образом крайне удобно добавлять новые операции, однако очень тяжело добавлять новые элементы в иерархию (необходимо добавлять соответствующие методы для обработки их посещений в каждом посетителе).

Данный шаблон позволяет группировать однотипные операции, применяемые над разнотипными объектами.

Примером может служить написание компилятора. Допустим, существуют разные объекты в синтаксисе языка программирования: вызовы методов и условные выражения. Комплиятор перед генерацией кода должен обойти все выражения (и вызовы методов и условные выражения) и проверить типо-безопасность, после чего сгенерировать соответствующий код. Соответственно будет два посетителя – для проверки безопасности типов и для генерации кода. У каждого из них будет по 2 метода – для вызовов методов и для условных операций. Таким образом при необходимости добавления новых шагов компиляции достаточно будет определить нового «посетителя» и вызвать его в соответствующее время.

**Контрольные вопросы**

1. Зачем используется шаблон «композитный объект» ?
2. Какой выигрыш от использования шаблона «Flyweight» ?
3. В чем основное назначение использования шаблона «Интерпретатор» ?
4. Какие достоинства шаблона «посетитель» ?
5. Какие недостатки шаблона «посетитель» ?