# Современные технологии программирования - 2
## Лабораторная работа №7. ШАБЛОНЫ «КОМПОЗИТНЫЙ ОБЪЕКТ», «FLYWEIGHT», «ИНТЕРПРЕТАТОР», «ПОСЕТИТЕЛЬ».

### Задание

1. Ознакомиться с краткими теоретическими сведениями.
2. Реализовать часть функционала рабочей программы в виде классов и их взаимодействий для достижения конкретных функциональных возможностей.
3. Применение одного из рассматриваемых шаблонов при реализации программы.

### Теоретическая часть

Способы синхронизации потоков. Шаблоны для работы с БД. ADO.NET, EF. DI, IoC. DLR.

### Краткие теоретические сведения

**Шаблоны работы с БД при разработке корпоративных приложений**

Существует набор современных шаблонов, используемых для разработчики широко-
масштабных корпоративных приложений - с количеством пользователей более 100 и
большим количеством взаимосвязанных приложений. Такие приложения требуют от-
дельных подходов к организации доступа к данным, поскольку количество хранимых
данных, классов и обращающихся клиентов растет.

*Шаблон Активная запись (Active record)*

![Active Record](https://github.com/kpi-r520/STP/blob/master/images/active_record.png)

Один объект управляет и данными, и поведением. Большинство этих данных постоян-
ны и их надо хранить в БД. Этот паттерн использует наиболее очевидный подход - хра-
нение логики доступа к данным в объекте сущности.

Объект является «обёрткой» одной строки из БД или представления, включает в себя
доступ к БД и логику обращения с данными.

Шаблон используется в частности в Ruby On Rails приложениях, ввиду его простоты.
Однако с увеличением количества разнообразных запросов растет сложность класса
данных и как правило логика запросов выносится в отдельный объект.

*Шаблон Шлюз к данным (Table Data Gateway)*

![Table Gateway](https://github.com/kpi-r520/STP/blob/master/images/table_gateway.png)

В данном случае отдельный класс для каждого класса данных занимается взаимодей-
ствием с базой данных. Он хранит в себе логику всех запросов (включая на сохранение
и удаление записей). Такой подход более гибкий и тестируемый, и позволяет содер-
жать отдельно данные и отдельно взаимодействие с базой данных. Однако для каждо-
го шлюза к данным код взаимодействия как правило повторяется (соединение с базой,
формирование команды источнику данных и т.п.), потому их часто абстрагируют в от-
дельный базовый класс для шлюзов. Еще такой шаблон часто называют репозиторий.

*Шаблон «отображение данных» (Data mapping)*

![Data Mapping](https://github.com/kpi-r520/STP/blob/master/images/data_mapping.png)

Крайне часто возникают проблема преобразования объекта данных в строку реляци-
онного источника. Такая же проблема может возникать при необходимости передачи
объекта по сети. Для ее решения принято создавать отдельные объекты (или методы
внутри класса данных) для преобразования объектов данных в данные принимаемо-
го источником вида. Эта процедура носит название отображения (mapping). Во время
отображения исправляются все несоответствия типов данных между объектом дан-
ных и источником данных.

Типичный маппер – с объекта данных в таблицу реляционного источника данных. Он
несет знание о названиях колонок в таблице и соответствующих свойствах объекта
данных, которые соответствуют этим колонкам.

**Шаблон «Композитный объект»**

![Composite](https://github.com/kpi-r520/STP/blob/master/images/composite_diagram.png)

Шаблон используется для составления объектов в древовидную структуру для пред-
ставления иерархий типа «часть целого». Данный шаблон позволяет унифицированно
обрабатывать как единичные объекты, так и объекты с вложенностью.

Простым примером может служить составление компонентов внутри обыкновенной
формы. Форма может содержать дочерние элементы (поля для ввода текста, цифр,
надписи, рисунки и т.п.); дочерние элементы могут в свою очередь содержать другие
элементы. Например, при выполнении операции растягивания формы необходимо,
чтобы вся иерархия растянулась соответствующим образом. В таком случае форма
рассматривается как композитный объект и операция растягивания применяется ко
всем дочерним элементам рекурсивно.

Данный шаблон удобно использовать при необходимости представления и обработки
иерархий объектов.

**Шаблон «Flyweight»**

![Flyweight](https://github.com/kpi-r520/STP/blob/master/images/Flyweight_diagram.png)

Шаблон используется для уменьшения количества объектов в приложении путем раз-
деления этих объектов между участками приложения. Flyweight представляет собой
разделяемый объект. Хорошим примером является следующее изображение:

![Flyweight](https://github.com/kpi-r520/STP/blob/master/images/Flyweight_diagram_2.png)

Кажется, будто для каждой буквы существует отдельный объект. На самом деле физи-
чески объект всего один, существует лишь множество ссылок на него.

Очень важной является концепция «внутреннего» и «внешнего» состояний. Внутреннее
состояние отображает данные, характерные конкретно разделяемому объекту (на-
пример, код буквы); внешнее состояние несет информацию о его применении в при-
ложении (например, строка и колонка). Внутреннее состояние сохраняется в самом
разделяемом объекте, внешнее – в объектах приложения (контекста использования
разделяемого объекта).

![Flyweight](https://github.com/kpi-r520/STP/blob/master/images/Flyweight_diagram_3.png)

Данный шаблон очень хорошо применять в случаях, когда используется множество
одинаковых объектов (например, графических примитивов).

**Шаблон интерпретатор**

![интерпретатор](https://github.com/kpi-r520/STP/blob/master/images/interpreter_diagram.png)

Данный шаблон используется для предоставления грамматики и интерпретатора для
выбранного языка (например, скриптового). Грамматика языка представлена терми-
нальными и нетерминальными символами, каждый из которых интерпретируется в
контексте использования. Клиент передает контекст и сформированное предложение
в используемом языке в терминах абстрактного синтаксического дерева (древовид-
ная структура, однозначно определяющая иерархию вызова под-выражений), каждое
выражение интерпретируется отдельно с использованием контекста. В случае наличия
дочерних выражений, родительское выражение интерпретирует сначала дочерние
(рекурсивно), а потом вычисляет результат собственной операции.

Шаблон удобно использовать в случае небольшой грамматики (иначе разрастется ко-
личество используемых классов) и относительно простого контекста (без взаимозави-
симостей и т.п.). Данный шаблон определяет базовый каркас интерпретатора, который
с помощью рекурсии возвращает результат вычисления предложения на основе ре-
зультатов отдельных элементов.

При использовании данного шаблона очень легко реализовывается и расширяется
грамматика, а также добавляются новые способы интерпретации выражений.

**Шаблон «посетитель»**

![посетитель](https://github.com/kpi-r520/STP/blob/master/images/visitor_diagram.png)

Шаблон посетитель позволяет указывать операции над элементами без изменения
структуры конкретных элементов. Таким образом крайне удобно добавлять новые
операции, однако очень тяжело добавлять новые элементы в иерархию (необходимо
добавлять соответствующие методы для обработки их посещений в каждом посетите-
ле).

Данный шаблон позволяет группировать однотипные операции, применяемые над раз-
нотипными объектами.

Примером может служить написание компилятора. Допустим, существуют разные объ-
екты в синтаксисе языка программирования: вызовы методов и условные выражения.
Комплиятор перед генерацией кода должен обойти все выражения (и вызовы методов
и условные выражения) и проверить типо-безопасность, после чего сгенерировать со-
ответствующий код. Соответственно будет два посетителя – для проверки безопасно-
сти типов и для генерации кода. У каждого из них будет по 2 метода – для вызовов ме-
тодов и для условных операций. Таким образом при необходимости добавления новых
шагов компиляции достаточно будет определить нового «посетителя» и вызвать его в
соответствующее время.

**Контрольные вопросы**

1. Зачем используется шаблон «композитный объект» ?
2. Какой выигрыш от использования шаблона «Flyweight» ?
3. В чем основное назначение использования шаблона «Интерпретатор» ?
4. Какие достоинства шаблона «посетитель» ?
5. Какие недостатки шаблона «посетитель» ?