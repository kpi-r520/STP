# Современные технологии программирования - 2
## Лабораторная работа №6. ШАБЛОН «МЕДИАТОР», «ФАСАД», «МОСТ», «ШАБЛОННЫЙ МЕТОД».

### Задание

1. Ознакомиться с краткими теоретическими сведениями.
2. Реализовать часть функционала рабочей программы в виде классов и их взаимодействий для достижения конкретных функциональных возможностей.
3. Применение одного из рассматриваемых шаблонов при реализации программы.

### Теоретическая часть

Сериализация, контракты данных. Потоки, задачи. Модели работы с потоками. Принципы проектирования.

### Краткие теоретические сведения

**Принципы проектирования**

*DRY*

Принцип Don’t Repeat Yourself (DRY) гласит, что в исходных кодах программного продукта не должно быть повторений. Данные повторения могут наблюдаться на различных уровнях – от повторений наборов строк кода (абсолютно аналогичные строчки в различных местах проекта) до различной реализации повторяющейся функциональности. Повторений избегать следует по нескольким причинам: прежде всего, код без повторений значительно меньше и значительно легче читается; во-вторых, при нахождении ошибки в коде, имеющем повторения, имеется высокий шанс не знать/забыть исправить эту же ошибку в другом месте; в-третьих, при создании идентичного кода вы не только копируете функциональность, но и ошибки; в-четвертых, при необходимости добавления новых возможностей везде где есть повторения необходимо внести соответствующие корректуры. Повторения легко исправить применив соответствующие техники рефакторинга – вынесение метода/интерфейса/класса и др.

*KISS*

Принцип Keep it simple, Stupid! (KISS) предлагает избегать излишнего усложнения компонентов системы. Считается, что система состоящая из множества маленьких простых частей работает значительно более надежно, чем одна большая сложная система. Данной философии следует сообщество Unix, где каждая программа выполняет ровно одну функцию, но при этом выполняет ее на абсолютно хорошо (Do one thing right). Это также способствует удовлетворению известного афоризма «The system obviously has no errors rather than system has no obvious errors» (очевидно, что в системе нет ошибок; в системе нет очевидных ошибок»). Использование простых конструкций упрощает читаемость и понимаемость исходных кодов.

*YOLO*

Принцип You only load it once! (YOLO) указывает на необходимость подгрузки инициализационных и конфигурационных переменных один раз при запуске программы, во избежание проблем со скоростью (повторные считывания данных с винчестера).

*Принцип Парето*

Принцип Парето применяется ко множеству различных событий и определяет процентное соотношение 80-20. Несколько примеров применения принципа парето:
* 80% нагрузки на сервер создает 20% приложения;
* 80% всего исходного кода приложения пишется за 20% времени;
* 80% ошибок программного обеспечения можно устранить закрыв лишь 20% багов.
Таким образом, необходимо помнить о том, что для решения большинства проблем необходимо приложить лишь малую часть усилий. Однако для доведения приложения до состояния совершенства может стоить огромную сумму (80%).

*YAGNI*

Принцип You ain’t gonna need it предлагает отказаться от некоторых решений в силу того, что они попросту не понадобятся. Достаточно известен факт, что программисты любят обощать и предоставлять универсальные решения на все случаи жизни. Очень часто достаточно простого и работающего решения вместо универсального, поскольку другие случаи вряд ли будут рассматриваться в дальнейшем. Есть необходимый набор функциональности, который необходимо реализовать; добавление излишней гибкости не только загромоздит код, но и уменьшит ход процесса разработки.

**Шаблон «медиатор»**

![Медиатор](https://github.com/kpi-r520/STP/blob/master/images/mediator_diagram.png)

Шаблон «медиатор» используется для определения взаимодействия объектов посредством другого объекта (вместо хранения ссылок друг на друга). Данный шаблон похож на шаблон «команда», однако в данном случае вместо хранения данных про конкретное действие, хранятся данные про взаимодействия между компонентами.

Данный шаблон удобно применять в случаях, когда множество объектов взаимодействует между собой некоторым структурированным образом, однако сложным для понимания. В таком случае вся логика взаимодействия выносится в отдельный объект. Каждый из взаимодействующих объектов хранит ссылку на объект «медиатор».

«Медиатор» напоминает дирижера при управлении оркестром. Дирижер следит за тем, чтоб каждый инструмент играл в правильное время и в согласии с другими инструментами. Функции «медиатора» полностью это повторяют.

**Шаблон «Фасад»**

![Фасад](https://github.com/kpi-r520/STP/blob/master/images/facade_diagram.png)

Шаблон «фасад» предополагает создание единого унифицированного способа доступа к подсистеме без раскрытия внутренних деталей подсистемы. Поскольку подсистема может состоять из множества классов, а количество ее функций - не более десяти, то во избежание создания «спагетти-кода» (когда все тесно связано между собой)выделяют один общий интерфейс доступа, способный правильным образом обращться ко внутренним деталям. Это также абстрагирует пользователей от изменений в подсистеме (внутренняя реализация может меняться, а предоставляемые услуги нет), что также сократит количество изменений в использующих фасад классах (без фасада пришлось бы изменять исходные коды во множестве точек).

Естественно, твердого условия полного закрытия внутренних классов подсистемы не стоит – при необходимости можно обращаться к отдельным классам напрямую, минуя объект фасад.

**Шаблон «Мост»**

![Мост](https://github.com/kpi-r520/STP/blob/master/images/bridge_diagram.png)

Шаблон «Мост» используется для разделения интерфейса и его реализации. Это необходимо в случаях, когда может существовать несколько различных абстракций, над которыми можно проводить действия различными способами. Вот пример системы без использования шаблона «Мост»:

![Мост](https://github.com/kpi-r520/STP/blob/master/images/bridge_diagram_2.png)

В данном случае при появлении новых типов окон будет необходимость создания новых классов их реализаций. Это ведет к стремительному увеличению количества классов и путаницы в исходном коде. Вот так это выглядит с использованием шалона «мост»:

![Мост](https://github.com/kpi-r520/STP/blob/master/images/bridge_diagram_3.png)

Таким образом можно отделить абстракцию от ее реализаций, и добавлять новые абстракции независимо от реализаций.

**Шаблон «Шаблонный метод»**

![Шаблонный метод](https://github.com/kpi-r520/STP/blob/master/images/template_method_diagram.png)

Шаблон «шаблонный метод» позволяет реализовать пошагово алгоритм в абстрактном классе, но оставить специфику реализации подклассам. Можно привести в пример формирование веб-странички: необходимо добавить заголовки, содержимое страницы, добавляемые файлы и нижнюю часть странички. Код для добавления содержимого страницы может быть абстрактным и реализовываться в различных классах – AspNetCompiler, HtmlCompiler, PhpCompiler и т.п. Добавление всех остальных элементов выполняется с помощью исходного абстрактного класса с алгоритмом. 

Данный шаблон несколько напоминает шаблон «фабричный метод», однако область его использования совершенно иная – для пошагового определения конкретного алгоритма; более того, данный шаблон не обязательно создает новые объекты – лишь определяет последовательность действий. Вот пример на языке C# использования данного шаблона:

```
public class PageFormer
{
void FormHeaders() { … }
void FormFooters() { … }
void FormAddedFiles() { … }
abstract void FormContent();
void FormPage()
{
FormHeaders();
FormContent();
FormFooters();
FormAddedFiles();
}}
public class AspNetCompiler : PageFormer
{
override void FormContent() { … }
}
```

**Контрольные вопросы**

1. Расскажите про KISS, DRY, YAGNI, закон парето.
2. Зачем используется шаблон «медиатор» ?
3. Чем отличается шаблон «шаблонный метод» от «фабричного метода» ?
4. Какую функциональность добавляет шаблон «мост»?
5. Зачем применяется шаблон «фасад» ?