# Современные технологии программирования - 2
## Лабораторная работа №4. ШАБЛОНЫ «АДАПТЕР», «СТРОИТЕЛЬ», «КОМАНДА», «ЦЕПОЧКА ОТВЕТСТВЕННОСТИ», «ПРОТОТИП».

### Задание

1. Ознакомиться с краткими теоретическими сведениями.
2. Реализовать часть функционала рабочей программы в виде классов и их взаимодействий для достижения конкретных функциональных возможностей.
3. Применение одного из рассматриваемых шаблонов при реализации программы.


### Теоретическая часть

Домены, модули, сборки, сателитные сборки. IL-код. Рефлексия. Строгое именование сборок. Антипаттерны.

### Краткие теоретические сведения

**«Анти-шаблоны» проектирования**

Анти-паттерны (anti-patterns), также известные как ловушки (pitfalls) — это классы наиболее часто внедряемых плохих решений проблем. Они изучаются, как категория, в случае когда их хотят избежать в будущем, и некоторые отдельные случаи их могут быть распознаны при изучении неработающих систем.

Термин происходит из информатики, из книги «Банды четырёх» Шаблоны проектирования, которая заложила примеры практики хорошего программирования. Авторы назвали эти хорошие методы «шаблонами проектирования», и противоположными им являются «анти-паттерны». Частью хорошей практики программирования является избегание анти-паттернов.

Больше информации можно найти [в википедии][1]

**Шаблон «Адаптер»**

![«Адаптер»](https://github.com/kpi-r520/STP/blob/master/images/adapter_diagram.png)

Шаблон «адаптер» используется для адаптации интерфейса одного объекта к другому. Например, существует несколько библиотек для работы с принтерами, однако каждая имеет разный интерфейс (хотя одинаковые возможности и назначения). Имеет смысл разработать унифицированный интерфейс (сканирование, асинхронное сканирование, двустороннее сканирование, поточное сканирование и т.п.), и реализовать соответствующие адаптеры для приведения библиотек к унифицированному интерфейсу. Это позволит в программе обращаться к общему интерфейсу, а не приводить различные сценарии работы в зависимости от способа реализации библиотеки.

Адаптеры также называются «обертками».

**Шаблон «Строитель»**

![«Строитель»](https://github.com/kpi-r520/STP/blob/master/images/builder_diagram.png)

Шаблон «строитель» используется для отделения процесса создания(инстанциирования) объекта от его представления. Это уместно в случаях, когда объект имеет сложный процесс создания (например, Web-страничка как элемент полного ответа web-сервера) или когда объект должен иметь несколько различных форм создания (например, при конвертации текста из формата в формат).

Возьмем процесс построения ответа на запрос web-сервера. Построение состоит из следующих частей: добавление стандартных заголовков (дата/время, имя сервера, проч.), код статуса (после поиска соответствующей странички на сервере), заголовки ответа (тип содержимого, проч.), содержимое, прочее. Каждый из этих этапов может быть абстрагирован в отдельный метод строителя. Это даст следующие выгоды:

- Более гибкий контроль над процессом создания странички;
- Независимость от внутренних изменений – например, изменение названия сервера не сильно нарушит процесс построения ответа;
- Простота реализации частей – каждая часть отвечает за конкретный участок, таким образом значительно упрощается понимание работы системы;
- Возможность использования различных интерпретаторов при построении странички
– например, если наш сервер обслуживает не только http страницы, но и php/asp.net странички.

**Шаблон «Команда»**

![«Команда»](https://github.com/kpi-r520/STP/blob/master/images/command_diagram.png)

Шаблон «команда» преобразует обычный вызов метода в класс. Таким образом действия в системе становятся полноправными объектами. Это удобно в следующих случаях:

* Когда необходима развитая система команд – известно, что команды будут добавляться;
* Когда необходима настраиваемая/гибкая система команд – когда появляется необходимость добавлять командам возможность отмены, логгирования и проч.;
* Когда необходима возможность составления цепочек команд или вызова команд в определенное время;

Объект команда сам по себе не выполняет никаких фактических действий кроме перенаправления запроса получателю (т.е. команды все же выполняются получателем), однако эти объекты могут сохранять данные для поддержки дополнительных функций – отмены, логгирования и проч. Например, команда вставки символа может запоминать символ, и при вызове отмены вызывать соответствующую функцию вытирания символа. Можно также определить параметр «применимости» команды (например, на картинке писать нельзя) – и использовать этот аттрибут для засвечивания соответствующей пиктограммы в меню.

Такой подход к командам позволяет построить очень гибкую и настраиваемую систему команд. В большинстве приложений это будет излишним (используется упрощенный вариант), однако жизненно-важно в приложениях с большим количеством команд (редакторы).

**Шаблон «Цепочка ответственности»**

![«Цепочка ответственности»](https://github.com/kpi-r520/STP/blob/master/images/chain_of_responsibility_diagram.png)

Шаблон «цепочка ответственности» отчасти можно наблюдать в жизни, когда подписание соответствующего документа проходит от его составления у одного из сотрудников компании через менеджера и начальника до главного начальника, который ставит свою подпись.

Примером из жизни можно считать обработку javascript событий в современных браузерах: каждый html элемент имеет возможность обрабатывать набор событий (например, клик мышки – onclick), однако не всегда удобно указывать обработчик для каждого элемента. Например, есть таблица, в каждой строчке которой – кнопка на удаление строки. Можно поставить обработчик на каждую кнопку, что вызовет проблемы при динамическом построении таблицы (появляются новые строчки – нужно добавлять обработчики, и отслеживать каким строкам обработчики уже поставлены; при удалении строк обработчики снимать); либо можно поставить обработчик на элемент tbody, который вмещает в себя все строки. Событие вызовется на кнопке, не найдет обработчика, вызовется на колонке, потом на строке, потом на tbody.

Таким образом, данный шаблон позволяет легко отделить обработчики событий от места их возникновения и дать возможность более гибко настраивать обработку. Это целесообразно, когда события могут возникнуть во многих местах и имеется множество потенциальных обработчиков.

Для построения такой иерархии необходим простой связанный список обработчиков, где каждый обработчик хранит объект «отцовского» обработчика, то есть следующего в цепочке (на случай если событие не было обработано). 

По примеру этого шаблона работают все системы событий: браузерные, WinForms, WPF.

**Шаблон «Прототип»**

![«Прототип»](https://github.com/kpi-r520/STP/blob/master/images/prototype_diagram.png)

Шаблон «прототип» используется для создания объектов по «шаблону» (или «чертежу», «эскизу») путем копирования шаблонного объекта. Для этого определяется метод «клонировать» в объектах этого класса.

Данный шаблон удобно использовать, когда заранее известно как будет выглядеть конечный объект (минимизируется количество изменений к объекту путем создания шаблона), а также для удаления необходимости создания объекта - создание происходит за счет клонирования, и вызывающей программе совершенно нет необходимости знать, как создавать объект.

Также, это позволяет манипулировать объектами во время выполнения программы путем настраивания соответствующих шаблонов; значительно уменьшается иерархия наследования (поскольку в ином случае это были бы не шаблоны, а вложенные наследующиеся классы). 

Пример реализации шаблона:

```
abstract class ColorPrototype
{
	public abstract ColorPrototype Clone();
}

class RgbColor: ColorPrototype
{
	private int _red;
	private int _green;
	private int _blue;
	
	public override ColorPrototype Clone() 
	{
		Console.WriteLine( «Cloning color RGB: 	{0,3},{1,3},{2,3}», _red, _green, _blue);
		return this.MemberwiseClone() as ColorPrototype;
	}
}
```

**Контрольные вопросы**

1. Что такое антипаттерн ?
2. Зачем используются адаптеры?
3. В каких случаях стоит применять шаблон «строитель» ?
4. Какие можно привести примеры использования шаблона «цепочка ответствен-
ности»?
5. Какая функция .NET Framework’а реализует шаблон «прототип»?

[1]: <https://en.wikipedia.org/wiki/Anti-pattern>
